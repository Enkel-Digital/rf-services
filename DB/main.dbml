// https://www.dbml.org/docs/

// @todo can we split dbml files up, so that we can define a DB schema over many files
// @todo convert bigint to int if possible
// @todo convert most variable length strings to fixed lengths
// @todo Might wanna use unsigned int if possible?

// Legend:
// PG (Attribute) -> PostgreSQL/SQL (preferred DB choice)
// FS (Attribute) -> Firestore/NoSQL (preferred DB choice)
// Trimmable (Attribute) -> Data that can be warehoused by deleting older data from production after backing up everything into data warehouse

Project RF {
  database_type: 'PostgreSQL'
  Note: 'SQL DB for RF'
}

// FS
// Business
// NOTE: There is no verified_email field as the signup flow explicitly requires email verification before firebase auth account is even created
Table business {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  // createdBy int [ref: > businessUsers.id, not null] // To identify the admin that created the business account.
  // approvedBy varchar [not null] // To identify CE admin that approved and verified this company
  createdBy int [ref: > businessUsers.id, null] // To identify the admin that created the business account.
  approvedBy varchar [null] // To identify CE admin that approved and verified this company
  name varchar [not null]
  email varchar [not null, unique] // Company email
  // @todo might not need country code here? we should include country code somewhere else? or base64 encode this...
  // phoneNumber varchar [not null, unique] // Includes area code
  deleted boolean [default: false]
}

// @todo need a new_biz user table

// FS
// Individual software users (employees) of a Business
Table businessUsers {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  businessID int [ref: > business.id, not null]
  admin boolean [default: false]
  permissions varchar // Perhaps use an array?
  name varchar [not null]
  email varchar [not null, unique]
  // phoneNumber varchar [null] // Includes area code
  // @todo Might not be stored here
  // profilePictureURL varchar [null]
  // verified_phone boolean [default: false]
  deleted boolean [default: false]
}

// Table used to temporarily store new businessUsers creation requests
// Data stored here will also be sent to the employees' email for them to proof their identify
// Will be removed once partnerAccount creation is fully completed
Table new_businessUsers {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  businessID int [ref: > business.id, not null]
  email varchar [not null, unique]
  token varchar [not null]
  admin boolean [default: false]
  // Is this the first account of partner? First account defaults to an admin account
  firstAdmin boolean [default: false]
}

// Consider moving this to NoSQL/FS
// Table businessUserSettings {
//   userID int [pk, not null, ref: - businessUsers.id]
//   // @todo Add a updatedAt timestamp
// }










// telegram deeplinking tokens
Table links {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  createdBy int [ref: > businessUsers.id, not null]

  // botID int [ref: > bots.id, not null]
  surveyID int [ref: > surveys.id, not null]
  
  name varchar [not null]
  description varchar [null]
  
  // @todo This could be a paid feature
  dateStart bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  dateEnd bigint [null]
  
  // token used with bot's username to generate the full link
  // Random alphanumeric string generated by DB, can be changed to generate by service before inserting
  // Limited to 64 chars as thats the max length of the URL query value that telegram deep linking can work with
  linkToken varchar(64) [not null, unique, default: `concat(md5(random()::text), md5(random()::text))`]
  // Alternative using https://stackoverflow.com/a/41608000/13137262
  // linkToken varchar [not null, unique, default: `gen_random_uuid()`]
}

Table linkTags {
  id bigint [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  // linkID int [ref: > links.id, not null]
  linkID int [not null]
  // @todo Limit the varchar length
  tag varchar [not null]
}
Ref: linkTags.linkID > links.id [delete: cascade, update: no action]
// aHHHHHH the issue is because, reviews table uses links.id ... then cannot delete, cos u cannot delete links...

// no such thing as deleting links, can only set end date to now so that it can no longer be used.
// Make sure the bot ensures that the link is valid in validateLink
// so then in the UI, we will show 2 categories of links, 1 "end of use"
// 1 cat for still running links












// Accounts for users (users that use our service to feedback to companies)
// Values with "t_" prepended means values from telegram
// Subsequently any new platform specify values will be added with their abbrev prepended
Table users {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]

  // Origin, where did the user came from?
  // EVery valid interaction must be started from a deeplink
  linkID int [ref: > links.id, not null]
  
  // This is not unique, because 1 user can do many surveys
  t_chat_id varchar [not null] // telegram chat ID

  deleted boolean [default: false]
}

// Settings the user can set and save like diff notifications or what not
// Table userSettings {
//   id int [pk, not null, ref: - users.id]
// }

// So like say a new user uses our service, and the company wanna tag them, either based on the time they first sent feedback or what not. Or location?
// This can only be set when the user use the start command to register themselves right
// This is different from linkTags, where that describes the link, whereas this describes the user.
// Tags describing users, set by the developers
// Give users tags to filter and send to specific group of users
// Used to group user's together to mass mail them
Table userTags {
  id bigint [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  userID int [ref: > users.id, not null]

  // Can be in any format the developer wants it to be, can be a UUID or just simple strings
  // e.g. timezone, countryCode
  // @todo Limit the varchar length
  tag varchar [not null]
}












// @todo add columns start/end, to allow us to specify when this is avail to user for? Like good for setting promos
// All subscription plans across time
Table subscriptionPlans {
  id int [pk, increment, not null, unique] // This is also the "planID"
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  available boolean [default: true] // By default all plans are available // @todo Can change to be a procedure to be executed to see if this is avail?
  name varchar [not null]
  copywriting varchar [not null] // HTML allowed
  currency varchar [not null]
  price int [not null] // Price in the specified currency
  // @todo Instead of this, maybe something diff
  totalPoints int [not null]
}

// @todo Create seperate table for country codes for subscription plans and other tables
  // Country that this plan is available in = All countries if none specified
  // Usually need to specify and usually the same as the currency of the plan.
  // Multiple rows, 1 row for each unique countryCode
  // countryCode varchar [not null]

// FS
// @todo add columns start/end, to allow us to specify when this is avail to user for? Like good for setting promos
// All topupOptions allowed other then the custom points topup
Table topupOptions {
  id int [pk, increment, not null, unique] // This is also the "topupID"
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  available boolean [default: true] // By default all plans are available // @todo Can change to be a procedure to be executed to see if this is avail?
  name varchar [not null]
  copywriting varchar [not null] // HTML allowed
  currency varchar [not null]
  price int [not null]
  totalPoints int [not null]
}












// @todo Maybe move the table below into new SQL DB of billing service

// Trimmable + PG
// Since planID is fixed overtime, it is used to get cost of plan and currency, instead of storing a copy of it in this table
Table businessPlans {
  id bigint [pk, increment, not null, unique]
  // @todo Add updatedAt to track when this is updated for analytics purposes?
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  businessID int [ref: > business.id, not null] // Many rows with each row being 1 plan in users history
  planID int [ref: > subscriptionPlans.id, not null]
  // Might look into using ISO 8061 defaults, but using unix seconds for now for consistency
  start bigint [not null] // Although can be generated, using not null and no default, forces server to always generate
  end bigint [null]
}

// Trimmable + PG
// Since topupID is fixed overtime, it is used to get cost of plan and currency, instead of storing a copy of it in this table
// Each topup is only valid in same period it is purchased. Determined by checking if purchaseTime is between start and end of current period
Table businessPlanTopups {
  id bigint [pk, increment, not null, unique]
  // @todo Add updatedAt to track when this is updated for analytics purposes?
  purchaseTime bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  businessID int [ref: > business.id, not null] // Many rows with each row being 1 topup in users history
  topupID int [ref: > topupOptions.id, not null]
}

// PG + Trimmable (keep like the latest 20 user past classes, allow user to request for more)
// Transactions (user feedback ... to compute business usage)
Table transactions {
  id bigint [pk, increment, not null, unique]
  actionTime bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`] // TS should be provided by client, but defaults to server timestamp if none
  botID int [ref: > bots.id, not null]
  // Might look into using ISO 8061 defaults, but using unix seconds for now for consistency
  startTime bigint [not null]
}
