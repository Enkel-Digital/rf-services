// https://www.dbml.org/docs/

// @todo convert bigint to int if possible
// convert most variable length strings to fixed lengths

// Legend:
// PG (Attribute) -> PostgreSQL/SQL (preferred DB choice)
// FS (Attribute) -> Firestore/NoSQL (preferred DB choice)
// Trimmable (Attribute) -> Data that can be warehoused by deleting older data from production after backing up everything into data warehouse

Project RF {
  database_type: 'PostgreSQL'
  Note: 'SQL DB for RF'
}

// @todo can we plait the dbml files up, so that we can have many of this?
// @todo Since we assume it is 1 bot for each "service" the devs run, we dun care what service, we just care about the bot...

// FS
// Business
// NOTE: There is no verified_email field as the signup flow explicitly requires email verification before firebase auth account is even created
Table business {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  // createdBy int [ref: > businessUsers.id, not null] // To identify the admin that created the business account.
  // approvedBy varchar [not null] // To identify CE admin that approved and verified this company
  createdBy int [ref: > businessUsers.id, null] // To identify the admin that created the business account.
  approvedBy varchar [null] // To identify CE admin that approved and verified this company
  name varchar [not null]
  email varchar [not null, unique] // Company email
  // @todo might not need country code here? we should include country code somewhere else? or base64 encode this...
  // phoneNumber varchar [not null, unique] // Includes area code
  deleted boolean [default: false]
}

// @todo need a new_biz user table

// FS
// Individual software users (employees) of a Business
Table businessUsers {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  businessID int [ref: > business.id, not null]
  admin boolean [default: false]
  permissions varchar // Perhaps use an array?
  name varchar [not null]
  email varchar [not null, unique]
  // phoneNumber varchar [null] // Includes area code
  // @todo Might not be stored here
  // profilePictureURL varchar [null]
  // verified_phone boolean [default: false]
  deleted boolean [default: false]
}

// Table used to temporarily store new partnerAccounts creation requests
// Data stored here will also be sent to the employees' email for them to proof their identify
// Will be removed once partnerAccount creation is fully completed
Table new_partnerAccounts {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  businessID int [ref: > business.id, not null]
  email varchar [not null, unique]
  token varchar [not null]
  admin boolean [default: false]
  // Is this the first account of partner? First account defaults to an admin account
  firstAdmin boolean [default: false]
}

// Consider moving this to NoSQL/FS
Table businessUserSettings {
  userID int [pk, not null, ref: - businessUsers.id]
  // @todo Add a updatedAt timestamp
}

// @todo Might wanna store link to the bot, but how to update if the name of bot is updated? Or can the name be changed?
Table bots {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  createdBy int [ref: > businessUsers.id, not null]
  // @todo Telegram bot token should be stored somewhere safer instead like vault or something.
  token varchar [not null, unique] // Token for the telegram bot itself
  businessID int [ref: > business.id, not null] // Dont need to be unique as we might allow the business to create multiple bots
  name varchar [not null, unique] // Maybe use ID or tokeN? that maps to vault entry?
  description varchar [null] // optional description
}

// API key / tokens table
// Might move to vault or a NoSQL format
//  NOOOO, dont use this? So instead of using this, we will use JWEs, where all info is stored in it.
// signed to prevent tampering, encrypted to prevent leaking information
// will be service account tokens instead.
Table serviceAccounts {
  id bigint [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  createdBy int [ref: > businessUsers.id, not null]
  token int [not null, unique]
  businessID int [ref: > businessUsers.id, not null]
  // Can be null, as they may use to create new bot without creating a bot ID yet
  // Can be an array too, to allow 1 token to control multiple bots? Or bad idea?
  botID int [ref: > bots.id, not null]
  name varchar [not null]
  // @todo Need a permissions array? or smth?
  permissions varchar // create a seperate table for permissions
  validFrom bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`, not null]
  validTill bigint [null] // Defaults to indefinite
}

// Links for the bots
Table links {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  createdBy int [ref: > businessUsers.id, not null]
  // Do we want to specify only who can access this link? Or are all links open to public?
  link varchar [not null, unique] // @todo This can be fixed max length
}
















// Table used to temporarily store user creation requests with their unique secret tokens for verification
// Data will be deleted once user completes signup/onboarding process

// So the reason why we need a seperate table, instead of storing the random token in the app_UUID column of the users table is because
// app_UUID should be soemthing to identify the user, and it can be public info. and since token CANNOT BE PUBLIC,
// it is not wise to store it there, as anyone can guess the app_UUID public info and take over control of the account

// perhaps use a jwt instead --> NOOOOO
// values up to 64 characters long only... so is better to be a secret token in a temp table? or smth?
// thus we are using tokens and thus this table is needed
Table pending_users {
  // Since token is unique, it is also used as the primary key
  // Limit token length to 60, to be below telegram API's deep linking limit of 64 characters
  token varchar(60) [pk, not null, unique]
  // @todo DA can include a field to calculate average time it took from token/pending_user generated to user registration event
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  botID int [ref: > bots.id, not null]
  // @todo SOMEHOW, this needs to be unique amongst the existing users too.
  // And I need a composite key too over here with the botID
  // @todo needs to have a limit
  app_UUID varchar [not null]
}

// @todo Maybe dun call this users, since this stores more then just users.
// This also store group chats and stuff, so rather be chats then users?
// @todo Need to change primary key to a composite key, of botID and app_UUID

// Accounts for users (users that use our service to feedback to companies)
// Values with "t_" prepended means values from telegram
Table users {
  id int [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  // When sending messages, devs have to define what bot to send with, and although they can use 1 bot for many different users, like the same bot for admins and normal app users, we dun really care, we just care about the botID.
  // The only way the dev is allowed to identify their users, is either by app_UUID/tags/t_chat_id (where chat_id is less common as devs should not be able to get it themselves)
  // Perhaps instead of bot id, use a telegram construct? Like a bot ID as defined by telegram?
  botID int [ref: > bots.id, not null]
  // @todo Should we add a unique constraint to this? or perhaps make it null?
  // Since technically some devs may choose to ignore this section.
  // actually cannot ignore right, if not u can just keep spamming the same user in... but this can be solved by making t_chat_id unique.
  // But actually no, cannot make chat ID unique since, a user can use multiple apps that all use teletif...
  // The easiest solution is to just make a unique composite
  // Perhaps add a default insert value, like a rand value if none is given then return to the dev
  // @todo needs to have a limit
  app_UUID varchar [not null] // Allow developers to uniquely identify their own users however they want.
  t_chat_id varchar [not null] // telegram chat ID
  deleted boolean [default: false]
}

// Settings the user can set and save like diff notifications or what not
Table userSettings {
  id int [pk, not null, ref: - users.id]
}

// Reviews from the user that comes in.
// PG + Trimmable (If trimmed, we need to make this into a seperate service that will hold a materialized view with cached result)
// PG needed for advance processing, to add a caching layer in front of queries for this with a 1 ~ 2 days expiry?
Table reviews {
  id bigint [pk, increment, not null, unique]
  reviewedOn bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  userID int [ref: > users.id, not null]
  // @todo We might want to somehow link to a product or tag. Use a seperate table instead
  // classID int [ref: > classes.id, not null]
  // @todo Add what time was the lesson so partner can take action -- Implement after classSchedule is implemented
  points int [not null]
  description varchar [null]
}

// Tags describing users, set by the developers
// Give users tags to filter and send to specific group of users
// Used to group user's together to mass mail them
Table userTags {
  id bigint [pk, increment, not null, unique]
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  userID int [ref: > users.id, not null]

  // Can be in any format the developer wants it to be, can be a UUID or just simple strings
  // e.g. timezone, countryCode
  // @todo Limit the varchar length
  tag varchar [not null]
}












// @todo Change this to be the sub plan of the business
// Trimmable + PG
// Since planID is fixed overtime, it is used to get cost of plan and currency, instead of storing a copy of it in this table
Table userPlans {
  id bigint [pk, increment, not null, unique]
  // @todo Add updatedAt to track when this is updated for analytics purposes?
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  userID int [ref: > users.id, not null] // Many rows with each row being 1 plan in users history
  planID int [ref: > subscriptionPlans.id, not null]
  // Might look into using ISO 8061 defaults, but using unix seconds for now for consistency
  start bigint [not null] // Although can be generated, using not null and no default, forces server to always generate
  end bigint [null]
}

// Trimmable + PG
// Since topupID is fixed overtime, it is used to get cost of plan and currency, instead of storing a copy of it in this table
// Each topup is only valid in same period it is purchased. Determined by checking if purchaseTime is between start and end of current period
Table userTopups {
  id bigint [pk, increment, not null, unique]
  // @todo Add updatedAt to track when this is updated for analytics purposes?
  purchaseTime bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  userID int [ref: > users.id, not null] // Many rows with each row being 1 topup in users history
  topupID int [ref: > topupOptions.id, not null]
}

// @todo Transactions table to track their use
// @todo need to add selected time of class to this too right?
// @todo Do we need to add the start time of the class?
// PG + Trimmable (keep like the latest 20 user past classes, allow user to request for more)
// Instead of relying on a Points table that needs to be updated every month, perhaps use a transactions table and the userPlans table to compute the points on demand
// Bascially records of user bookings and cancellation events and more
// Classes that the users have booked and did not cancel
Table userBookingTransactions {
  id bigint [pk, increment, not null, unique]
  actionTime bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`] // TS should be provided by client, but defaults to server timestamp if none
  userID int [ref: > users.id, not null]
  // classID int [ref: > classes.id, not null]
  points int [not null] // A copy of the points of the class at the moment of action, as points of a class can be changed by partner later on
  // Only store start time as end time should be computed using length of class
  // Might look into using ISO 8061 defaults, but using unix seconds for now for consistency
  startTime bigint [not null]
  // @todo might store end time too as a hack guard, as partners can change the length of the class to cheat the system and gain points even before class actually ended and then the user's cannot cancel.
}














// @todo add columns start/end, to allow us to specify when this is avail to user for? Like good for setting promos
// All subscription plans across time
Table subscriptionPlans {
  id int [pk, increment, not null, unique] // This is also the "planID"
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  available boolean [default: true] // By default all plans are available // @todo Can change to be a procedure to be executed to see if this is avail?
  name varchar [not null]
  copywriting varchar [not null] // HTML allowed
  currency varchar [not null]
  price int [not null] // Price in the specified currency
  totalPoints int [not null]
}

// @todo Create seperate table for country codes for subscription plans and other tables
  // Country that this plan is available in = All countries if none specified
  // Usually need to specify and usually the same as the currency of the plan.
  // Multiple rows, 1 row for each unique countryCode
  // countryCode varchar [not null]

// FS
// @todo add columns start/end, to allow us to specify when this is avail to user for? Like good for setting promos
// All topupOptions allowed other then the custom points topup
Table topupOptions {
  id int [pk, increment, not null, unique] // This is also the "topupID"
  createdAt bigint [default: `EXTRACT(EPOCH FROM now() at time zone 'utc')`]
  available boolean [default: true] // By default all plans are available // @todo Can change to be a procedure to be executed to see if this is avail?
  name varchar [not null]
  copywriting varchar [not null] // HTML allowed
  currency varchar [not null]
  price int [not null]
  totalPoints int [not null]
}
