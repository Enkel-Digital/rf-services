/**
 * Express Router for links APIs
 * Mounted on /links
 * @author JJ
 * @module Bot link APIs
 *
 * This router is mounted on a auth protected route,
 * thus individual auth verifier middleware not needed
 */

import express from "express";
const router = express.Router();

import SQLdb from "@enkeldigital/ce-sql";
import onlyOwnResource from "../middleware/onlyOwnResource";

import createLogger from "@lionellbriones/logging";
const logger = createLogger("routes:links");

/**
 * Get links for a bot
 * @name GET /links/?botID
 * @returns {object} Link object
 */
router.get("/", onlyOwnResource, async (req, res) => {
  try {
    const { botID } = req.query;

    const links = await SQLdb("links")
      .join("bots", "links.botID", "=", "bots.id")
      .where("links.botID", botID)
      .select(
        // This should be the "name" or ID of the bot registered with tele that shouldnt change
        // The name is used along with the token to generate the actual link
        "bots.name as botName",
        "links.id",
        "links.createdAt",
        "links.createdBy",
        "links.name",
        "links.description",
        "links.dateStart",
        "links.dateEnd",
        "links.linkToken"
      );
    //  orderBy createdAt?

    // Construct the link from the linkToken and botName for every link object
    for (const link of links) {
      link.link = `https://t.me/${link.botName}?start=${link.linkToken}`;
      delete link.linkToken;
      // @todo Is there anyway to optimize this? Since every botName is the same
      delete link.botName;
    }

    // Get the tags of the link
    // @todo How to combine with the above request...???
    // const linkTags: Array<{ [tag: string]: string }> = await SQLdb("linkTags")
    //   .join("links", "linkTags.linkID", "=", "links.id")
    //   .whereIn(
    //     "links.id",
    //     links.map((link) => link.id)
    //   )
    //   .select("linkTags.tag");
    // const tags: Array<string> = linkTags.map((tag) => tag.tag);

    // @todo Use above method instead in the future
    for (const link of links) {
      const tags = await SQLdb("linkTags")
        .where({ linkID: link.id })
        .select("tag");
      link.tags = tags.map((tag) => tag.tag);
    }

    res.status(200).json({ ok: true, links });
  } catch (error) {
    logger.error(error);
    res.status(500).json({ ok: false, error: error.message });
  }
});

/**
 * Save a new link
 * @name POST /links/new
 * @param {Number} botID
 * @param {Object} link
 * @returns {object} ok indicator
 *
 * @todo Limit this, so this needs to hook up with the billing service.
 */
router.post("/new", express.json(), async (req, res) => {
  try {
    const { link } = req.body;

    // @todo Check with Billing service that business is still able to create new link

    // Store the tags (defaults to empty array) for use later, and remove from the class object
    const tags: Array<string> = link.tags || [];
    delete link.tags;

    // Generate the linkToken

    // Save the link and read back the row with the values generated by DB
    // Return back the same columns as the ones in get links for bot API
    // Destructure out the first value from the returned array
    const [linkFromDB] = await SQLdb("links")
      .insert(link)
      .returning([
        "id",
        "createdAt",
        "createdBy",
        "name",
        "description",
        "dateStart",
        "dateEnd",
        "linkToken",
      ]);

    // Get the name of the bot to create the link
    const { name: botName } = await SQLdb("bots")
      .where({ id: link.botID })
      .select("name")
      .first();

    // Create the link and remove linkToken from response
    linkFromDB.link = `https://t.me/${botName}?start=${linkFromDB.linkToken}`;
    delete linkFromDB.linkToken;

    // Save the tags
    await SQLdb("linkTags").insert(
      tags.map((tag: string) => ({ linkID: linkFromDB.id, tag }))
    );

    res.status(201).json({
      ok: true,
      link: {
        ...linkFromDB,
        tags,
      },
    });
  } catch (error) {
    logger.error(error);
    res.status(500).json({ ok: false, error: error.message });
  }
});

/**
 * Update link details
 * @name PUT /links/:linkID
 * @returns {object} ok indicator
 */
router.put("/:linkID", (req, res) => {
  try {
    // @todo Update billing status
    res.json({ ok: false, error: "unimplemented" });
  } catch (error) {
    logger.error(error);
    res.status(500).json({ ok: false, error: error.message });
  }
});

/**
 * Delete link
 * @name DELETE /links/:botID
 * @function
 * @returns {object} ok indicator
 */
router.delete("/:botID", async (req, res) => {
  try {
    // @todo Update billing status
    res.json({ ok: false, error: "unimplemented" });
  } catch (error) {
    logger.error(error);
    res.status(500).json({ ok: false, error: error.message });
  }
});

module.exports = router;
